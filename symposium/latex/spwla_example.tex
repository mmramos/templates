\documentclass[10pt,twocolumn,twoside]{article}
\usepackage{graphicx,xcolor}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bm, bbm} % bold math
\usepackage{subfigure}
\usepackage{natbib}
\usepackage{enumitem}
\usepackage{float}
%\usepackage{mathptmx}
%\usepackage[labelfont=bf]{caption}
%\usepackage{epsfig,bm}
%\usepackage{amsfonts}
%\usepackage{lipsum}
%\usepackage{titlesec}
%\usepackage{titling}
\usepackage{spwla}
%\usepackage{showframe}
%\bibpunct{(}{)}{;}{a}{ }{,}
%\usepackage[labelfont={bf},justification=RaggedRight,textfont=normal]{caption}
\usepackage{caption}

%\captionsetup{labelfont=bf,textfont=normal,justification=justified,labelsep=endash,aboveskip=2pt}
\captionsetup{labelfont=bf,textfont=normal,justification=justified,aboveskip=2pt}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage[export]{adjustbox}
\usepackage[capitalize, nameinlink]{cleveref}
\crefdefaultlabelformat{#2\textbf{#1}#3} % <-- Only #1 in \textbf
\crefname{figure}{\textbf{Figure}}{\textbf{Figures}}
\Crefname{figure}{\textbf{Figure}}{\textbf{Figures}}
\crefname{table}{\textbf{Table}}{\textbf{Tables}}
\Crefname{table}{\textbf{Table}}{\textbf{Tables}}
%\newcommand{\rs}[1]{\mathstrut\mbox{\scriptsize\rm #1}}
%\newcommand{\rr}[1]{\mbox{\rm #1}}
%\newcommand*\mean[1]{\bar{#1}}
%\newcommand*\tran[1]{\tilde{#1}}
%use below 4 rows to avoid hyphenation
%\tolerance=1
%\emergencystretch=\maxdimen
%\hyphenpenalty=10000
%\hbadness=10000
\def\headername{{SPWLA 65$^\textbf{th}$ Annual Logging Symposium, May 18--22, 2024}}

\setcounter{page}{1}

\renewcommand{\thesubfigure}{\thefigure\alph{subfigure}}
\makeatletter
   \renewcommand{\p@subfigure}{}
   \renewcommand{\@thesubfigure}{(\alph{subfigure})\hskip\subfiglabelskip}
\makeatother


%\setcounter{page}{11}

\newcommand{\Erf}{\operatorname{Erf}}
\newcommand{\var}{\operatorname{var}}
\newcommand{\cov}{\operatorname{cov}}
\def\frech{Fr\'{e}chet\ }
%
% for vector symbols; write argument in math and bold
% can be used inside or outside mathmode
%
%
% transpose for matrices (math mode only)
%
\newcommand{\trp}{^{\text{\scriptsize T}} }
\newcommand{\itp}{^{-\text{\scriptsize T}} }
\newcommand{\inv}{^{-1} }
%
%  Super- or subscript in roman
%  in math mode or parmode
%
\newcommand{\sbr}[1]{\ensuremath{_{\mathrm{#1}}}}
\newcommand{\spr}[1]{\ensuremath{^{\mathrm{#1}}}}
%
%   Bibliography style

\bibliographystyle{spwla}


%****** REFERENCES *************************************************************
\def\thebibliography#1{\section{References}
\list
{\arabic{enumi}.}
{\settowidth\labelwidth{#1.}\leftmargin\labelwidth
\advance\leftmargin 0pt \labelsep 5pt \labelwidth 20pt \itemindent -10pt
\usecounter{enumi}}     \def\newblock{\hskip .11em plus .33em minus -.07em}
\sloppy \sfcode`\.=1000\relax
}\let\endthebibliography=\endlist

%
%   Title
%
\title{APPy Insights: The New Frontier in Petrophysical Software Planning}
%
%   Author(s)
%
\author{Mario Martins Ramos, Fernando Vizeu, Rodrigo Dutra, José Augusto Vitorino Dias, João Vitor Alves Estrella, Jordan Jusbig Salas Cuno, Ana Carla dos Santos Pinheiro, Fábio Júnior Damasceno Fernandes, Antonio Fernando Menezes Freire, Wagner Moreira Lupinacci}

% Headers
\headsep = 0.5 in
\footskip = 0.15 in
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancyhead[RO]{\bf{\headername}}
\fancyhead[LE]{\bf{\headername}}
\fancyfoot[C]{\color{gray}\thepage}

\begin{document}
\thispagestyle{empty}
%\small                   % 9pt is default size, but there is no 9pt article.
\twocolumn[\maketitle]   % set the title as one-column, rest two-column.
%\maketitle

\noindent \parbox[t]{75mm}{ \scriptsize \rmfamily \noindent
	
	Copyright 2024, held jointly by the Society of Petrophysicists and Well Log Analysts (SPWLA) and the submitting authors.
	
	This paper was prepared for the SPWLA 65$^\text{th}$ Annual Logging
        Symposium held in Rio de Janeiro, RJ, Brazil, May 18--22, 2024.
}
\textcolor[rgb]{0.00,0.00,0.00}{\rule{75mm}{0.3mm}}

\fancypagestyle{firststyle}
{
	\fancyhf{}
	\fancyhead[R]{\bf{\headername}}
	\fancyfoot[C]{\footnotesize \thepage}
}

\thispagestyle{firststyle}

\section{abstract}
The meteoric rise of the Python programming language did not happen in isolation. Alongside this development, there was a notable amplification in the processing capacity of contemporary computers. Together, these technological advances made it possible for computational operations, which were previously considered expensive and time-consuming, to become more accessible and implementable. This is especially true in the context of academic centers, where research and technological development find fertile ground. Within the vast field of research, petrophysical problems have reaped the benefits of these innovations. With expanded processing capabilities and the versatility of Python, researchers now have the ability to work with massive data sets, especially when it comes to oil wells. Operations ranging from simple data extraction from files in the LAS and DLIS formats, to tasks demanding intense computational power, like machine learning and inversion techniques, have become more efficient and achievable. However, despite these promising advances, one challenge persists. Many of the routines and algorithms that are meticulously developed during academic research are set aside after these activities conclude. These algorithms, rich in potential application, are forgotten, and if there's an interest in reusing them later on, there is often a need to almost redevelop from scratch. It is in this context that the relevance of this work arises. We aim to present practical solutions to this challenge, and one of the pillars of this solution is the software APPy (Petrophysics Evaluation in Python - acronymous in portuguese). This software aims to bridge the gap between researchers, both those with deep knowledge in programming and those unfamiliar with the field. APPy offers a platform where the production, reuse, and optimization of algorithms become more integrated and efficient processes, eliminating the barrier that often prevents the reuse of valuable solutions. In this way, we seek a more connected academia, where knowledge is shared and maximized for the benefit of research and practical application.


\section{introduction}
Python, over the years, has seen phenomenal growth, and it has become one of the most popular programming languages worldwide. Initially developed in the late 1980s by Guido van Rossum, Python's simplicity, readability, and versatility have made it the first choice for many developers and industries \citep{pysftw2021}. Its growth can be attributed to a combination of factors. One significant reason is its wide application in emerging fields, such as data science, artificial intelligence, machine learning, and web development.

Several studies and surveys, including those from Stack Overflow, have highlighted Python's soaring popularity. Stack Overflow, a major platform for developers to learn and share their knowledge, has observed an increasing number of questions related to Python over the years \citep{stackoverflow2017}. This is indicative of a growing community of Python developers and enthusiasts. Additionally, the language's extensive libraries and frameworks, coupled with a supportive community, have made Python an attractive choice for both beginners and experienced developers (\cref{fig:languages}).

\begin{figure}[H]
	\centering
	\adjincludegraphics[width=3.125in, trim={{.0
			\width} {.0\width} {.0\width} {0.0\width}},clip]%
	{figs/fig_1.png}
	%{Overview_examples_crop.png}
	\caption{Most popular languages survey \citep{stackoverflow2019,stackoverflow2022}.}
	\label{fig:languages}
\end{figure}

Also, based on the most recent data from Stack Overflow's annual developer survey, JavaScript maintains its status as one of the most popular and widely used programming languages in the world (\cref{fig:languages}). For several years running, an overwhelming majority of developers have reported using JavaScript, with its dominance evident across both front-end and back-end development domains \citep{jsstate2021}. The data suggests that the language's adaptability, coupled with the continual emergence of modern libraries and frameworks, has solidified its importance in the ever-evolving landscape of web technologies. Additionally, the active and expansive community support evident on platforms like Stack Overflow indicates that JavaScript's relevance is not merely a reflection of its historical significance but also a testament to its current vitality and potential for future innovation.

Considering database language, SQL's enduring relevance stems from its ubiquity across most relational database management systems, its standardization by ANSI, the optimized performance of relational databases, its maturity from decades of use, and its persistent demand in various tech job roles \citep{winand2012}. However, its prominence might be challenged in the future by the rise of NoSQL databases, potential advancements in newer query languages, and integrated platforms that provide query solutions without the direct need for SQL \citep{avantika2022}. Despite these challenges, as of 2023 to 2024, SQL's foundational position in data management suggests it will likely remain significant for years to come \citep{stackoverflow2022}.

The rapid growth of popularity of programing languages, results in one last question to answer: Is still valid to develop softwares, or everyone should learn some programing languages? While the production of software remains crucial in our technologically driven world \citep{usbureau2023}, with a growing demand seen in sectors like machine learning, IoT, and augmented reality, the need for individuals to learn programming is more nuanced. A basic understanding of programming concepts is beneficial for many, akin to how understanding arithmetic doesn't make everyone a mathematician. As digital transformation becomes more pervasive, underscored by reports like the World Economic Forum's "The Future of Jobs Report 2020" \citep{weforum2020} it's clear that a foundation in digital literacy is becoming increasingly important. However, this doesn't necessarily translate to proficiency in specific programming languages for everyone. Instead, understanding the logic and problem-solving approach inherent to programming may be more vital.

Consequently, despite the substantial proliferation of programming languages, there remains a valid need for the development of software applications to cater to the increasing demand for emergent technologies. Furthermore, the employment of the aforementioned technologies (Python, SQL, and Javascript) appears to be of significant relevance in the development of such software applications. 

Besides the global trend that drives software development in multiple application fields, the specific scenario of petrophysical software outlines a particularly distinctive niche within the technological spectrum. This software area is often highlighted, especially in the academic context, due to a series of challenges and opportunities that fuel innovation. Firstly, the cost associated with the licenses of these softwares are often high, making it frequently unfeasible given the budget constraints of many academic and research projects. Additionally, the operational opacity and the lack of transparent documentation regarding the functionalities and methods implemented in these software programs limit adaptability and customization. This limitation becomes particularly significant when considering the implementation of new methodologies and approaches, a challenge for both experienced developers and professionals who lack extensive programming experience. Thus, there's a growing demand for the development of more accessible, transparent, and adaptable solutions in the realm of petrophysical software. Therefore, this ``environment'' was conducive to the emergence of the petrophysical evaluation software APPy.


\section{Methodological premises of the APPy software}
The foundational principles guiding the development of the APPy software were twofold. First and foremost, it sought to address the primary requirements for software tailored to the academic needs pertaining to petrophysical evaluation within university environments. Secondly, it was imperative for APPy to establish itself as both competitive and dependable in the broader software landscape. Subsequent sections will delve deeper into these specific requirements and the rationale behind their prioritization.

\subsection{Academic necessities and development environment}
Petrophysics is commonly intertwined with geophysics, engineering, and geology. A significant portion of students in these fields have encountered, or will encounter, Python at some juncture in their academic journey \citep{guo2014}. It's thus anticipated that many students will incorporate Python into their research. Even those who don't work with Python directly often possess a foundational understanding of the language, enough to utilize code written by others. This familiarity has made Python a unifying language among students, fostering collaboration and innovation.

Given this context, the foundational design principle for the APPy software is its identity as a 'Python-centric' tool. This entails that the majority of its functionalities are linked to the Python language, ensuring that most students can effortlessly interact with and enhance the software to meet their specific academic requirements or those of their research group.

Adopting Python in academic settings addresses three primary challenges posed by other software:

\begin{itemize}
	\item Cost-efficiency: Python is free.
	\item Transparency: As an open-source, interpreted language, Python's workings are accessible and understandable.
	\item Modularity: Python boasts a plethora of libraries, including those tailored for geosciences and petrophysics.
\end{itemize}

While these advantages are particularly appreciated by students familiar with Python, they may pose barriers for those who don't regularly engage with the language.

\subsection{Competitiveness in the broad software landscape}

In today's highly competitive software landscape, it's paramount for software applications to have an edge, even during their developmental phases. To achieve this, it's indispensable for the software to adhere to two primary development methodologies: microservices and incremental development. Microservices architecture allows for flexibility and scalability by breaking down an application into smaller, independent services that communicate with one another. On the other hand, incremental development emphasizes the importance of continuous improvement by building software in small, manageable increments, ensuring that each new feature or enhancement is thoroughly tested and integrated. Adopting these strategies not only fosters adaptability and responsiveness but also positions the software favorably in a rapidly evolving market. \citep{fowler2016, cohn2005, rolakuchta2015}.

Based on \cite{fowler2016}, microservices are small, individual applications that work together to form a larger system. For a system to be reliable, each microservice must be stable, able to handle increased demand, and recover quickly from failures. Effective monitoring, clear documentation, and secure practices are also essential. In essence microservices can consistently deliver top performance in real-world conditions. In the APPy software, the concept of microservices is primarily implemented through the use of stable and reliable libraries for both Python and JavaScript. The microservices architecture is seamlessly integrated into APPy's core framework, particularly within its command structures. APPy can be operated from the command prompt, executing its primary functions via specific commands. These commands facilitate a range of well-log operations, from project creation and data import to advanced machine learning tasks. An simplified version of this operations are show in the \cref{fig:command_s}.

\begin{figure}[H]
	\centering
	\adjincludegraphics[width=1.125in, trim={{.0
			\width} {.0\width} {.0\width} {0.0\width}},clip]%
	{figs/appy_command_s.png}
	\caption{Illustration of how all interactions between users on APPy and the database are facilitated through commands.}
	\label{fig:command_s}
\end{figure}
The command structure offers a compelling solution to a prevalent problem in many software systems: the absence of modularity. Within APPy, enhancing the platform with new functionalities is made straightforward for users. All they need to do is introduce a new command alongside the existing ones.

Another development methodology prominently utilized in the APPy software is incremental development. This approach ensures that the software remains partially functional even in its early stages of production, permitting the client to engage with the product and offer feedback \citep{rolakuchta2015}. A classic illustration of incremental development can be found in \cref{fig:agile_kn}.

\begin{figure*}[t]
	\centering
	\adjincludegraphics[width=5.125in, trim={{.0
			\width} {.0\width} {.0\width} {0.0\width}},clip]%
	{figs/kniberg.png}
	\caption{Schematic illustration of incremental development: In the top scenario, the client receives only the final version of the software; in the bottom scenario, the client can use the software at each stage of development \citep{knibergagile2015}.}
	\label{fig:agile_kn}
\end{figure*}

\section{Overall APPy structure}

To address both academic demands and the competitiveness of the software, the decision was made to divide it into three parts: Stoneforge, APPy-core, and APPy-gui. This division allows separate teams to work on distinct portions of APPy with greater autonomy. By doing so, developers can exercise more creative freedom without compromising the software's overall structure and development process. This separation of components ensures that improvements or changes in one section do not adversely impact the others. Moreover, it provides clear delineation of responsibilities, allowing each team to specialize and hone their expertise in their respective areas, leading to a more efficient development cycle. 

Considering the overall operation of APPy, the APPy-core directly accesses the Stoneforge library by importing the library and executing its features. Within the APPy-core's source code, there is an API (Application Programming Interface) that allows for the retrieval of information from the database via the HTTP protocol. Consequently, through this API, the database can be viewed in a browser. This type of access is essential for APPy-gui to access and manipulate well data through an interactive interface. A schematic of this process is presented in \cref{fig:sub_appy}

\begin{figure}[]
	\centering
	\adjincludegraphics[width=2.125in, trim={{.0
			\width} {.0\width} {.0\width} {0.0\width}},clip]%
	{figs/appy_substructure.png}
	\caption{Appy conceptual estructure: }
	\label{fig:sub_appy}
\end{figure}

\subsection{Stoneforge}
Stoneforge is a cutting-edge petrophysical library developed in Python. This versatile library encompasses a spectrum of methodologies, ranging from classic techniques for reservoir property estimation—like porosity, clay content, and saturation—to more advanced modules focused on rock physics, pseudo-wells, and machine learning \citep{giecar2023}.

One of the foundational aspirations of the Stoneforge library is to act as a gateway to the APPy platform. This has been architected with inclusivity in mind, ensuring that Python enthusiasts of varying proficiencies can not only utilize the platform to its fullest but also contribute to its growth by integrating new functionalities.

For the intermediate Python user with a foundational understanding of petrophysics, Stoneforge simplifies many processes. They can easily import well data, preprocess it, and perform various operations—all without needing to have the APPy software installed. Furthermore, Stoneforge's commitment to open-source principles greatly augments the transparency of APPy. Given that Stoneforge lays bare many of APPy’s primary features, users and developers can have a clearer understanding and appreciation for the platform's capabilities and functionalities.

\subsection{APPy-core}
The APPy-core essentially serves as the "heart" of APPy. The entire software was originally designed around this core, with functionalities added later on. Although one can still use the APPy-core natively via command lines, this feature is quite limited. In its original design, the APPy-core acts as a manager for both database and petrophysical projects. When creating a project, an APPy user establishes two databases: one in SQL (sqlite) and another in HDF5.

SQL, a widely recognized database language that has been around since the 1970s \citep{boycechan1973}, remains popular to this day \citep{stackoverflow2022}. On the other hand, HDF5, another database language, might not be as well-known as SQL. However, it bears some structural similarities to SQL, with the added benefit of being more suited for storing vast amounts of data. These databases house well data, alongside other details like color codes, mnemonic patterns, and curve units.

Furthermore, the APPy-core has an API designed to simplify the development of a separate graphical user interface (GUI) from the main program. This API can be accessed via a browser using a specific HTTP port. Through the API, one can access the database and issue commands.

Adding new functionalities to APPy is done through commands, which consist of two files: the first has a .appy extension and contains a list of arguments, along with a header for GUI access, and the second file contains the desired functionality coded in Python.

\subsection{APPy-gui}
APPy-gui is a specialized interface designed primarily for the visualization and analysis of petrophysical and well log data. The interface is constructed using the Vue.js framework, a choice made for its component-driven architecture, which enables modular and maintainable code structures. These components facilitate the dynamic rendering of complex graphs and charts, a feature essential for deciphering intricate data patterns typical of petrophysics.

The backend operations of APPy-gui are anchored on a Node.js server. Node.js, with its non-blocking I/O and event-driven model, provides the capability to handle numerous simultaneous client requests, which is especially crucial when dealing with large and multifaceted petrophysical datasets. The interplay between the GUI and its data source is orchestrated through a Python-based API constructed with Flask and Flask RESTful. Flask offers a nimble framework for creating web services, while Flask RESTful extends this capability, providing a structured way to build endpoints for data retrieval, updates, and other CRUD operations. As such, the combined structure ensures efficient data flow between the backend and the APPy-gui, granting users the capability to manipulate and visualize their data seamlessly.

\subsection{Conclusions}
The development of APPy began in 2017, and it has now matured over a span of more than six years. Throughout this time, a myriad of students have collaborated on its evolution. While some devoted extended periods to its growth, others played a shorter, yet still significant, role. Every contributor, irrespective of their tenure, has left a distinct imprint on the application. The current version of APPy stands as a testament to the collective effort and dedication of these budding scholars. Beyond offering them an avenue to hone their skills in Python, the project also provided invaluable hands-on experience in software development, aiding their academic and professional journey.

\section{acknowledgments}
First and foremost, The authors would like to extend their gratitude to everyone involved in the software's development, especially Thiago Rebeque, Ana Carolina, Rishi Kumar Ray, João Reis, and Yuri Alves. We would also like to acknowledge the dedicated users of APPy over its six-year development phase: Jeniffer Nobre, Thaís Candido, Luane Erbe, Carolina Ferreira da Silva, Bruna Maia Imbuzeiro, Lídia Waltz, Isadora Dutra, and Juliana. Our appreciation extends to the Department of Geology and Geophysics, with a special mention to professors Rodrigo Bijani, Francisco Romério Abrantes Júnior, and Victor Matheus Joaquim Salgado Campos. Lastly, our heartfelt thanks go to PETROBRAS for their valuable support, which was instrumental in the development of this software.".

\section{nomenclature}
\makebox[1.5cm][l]{SQL}  Structured Query Language\\
\makebox[1.5cm][l]{API}  Application Programming Interface\\
\makebox[1.5cm][l]{HTTP} Hypertext Transfer Protocol\\
\makebox[1.5cm][l]{ANSI} American National Standards Institute

\bibliography{spwla_ref}

%\newpage

\section{about the authors}
\setlength\intextsep{0pt}
\begin{wrapfigure}{l}{0.33\linewidth}
	\includegraphics[width=1.0\linewidth]{logo_giecar3.png}
	\vspace{0.03in}
\end{wrapfigure}
\textbf{Mario Martins Ramos, Fernando Vizeu, Rodrigo Dutra, José Augusto Vitorino Dias, João Vitor Alves Estrella, Jordan Jusbig Salas Cuno, Ana Carla dos Santos Pinheiro, Fábio Júnior Damasceno Fernandes} Are all members of GIECAR - (Grupo de Interpretação Exploratória e Caracterização de Reservatórios).

\begin{wrapfigure}{l}{0.33\linewidth}
	\includegraphics[width=1.0\linewidth]{inct-gp.png}
	\vspace{0.03in}
\end{wrapfigure}
\textbf{Antonio Fernando Menezes Freire, Wagner Moreira Lupinacci} Are professors of Universidade Federal FLuminense (UFF), members of GIECAR and also members of the INCT-GP (Instituto Nacional de Ciência e Tecnologia Geofísica do Petróleo).

\end{document}
